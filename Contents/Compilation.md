# WebKit的编译过程

## 背景知识

一个大型的项目对内部不同组件之间的关系的维护是非常重要的。有一种常见的称呼叫做spaghetti code，就是指代码像意大利面条一样缠在一起没法分割。互相之间有非常强的耦合性以至于后期的重构，功能的增删都变得极其困难。

对C/C++项目来说spaghetti code体现在代码之间的循环引用，代码分层不清，以及设计架构上的对象所有权关系混乱。

**循环引用**

一种循环引用的情况是头文件之间的引用循环。比如`a.h`包含了`b.h`，然后`b.h`又直接或者间接的包含了`a.h`。在大型项目中头文件包含的层次往往非常深，所以在往一个头文件里面添加`#include`宏的时候很难判断当中是不是有循环引用。而循环引用有时候并不一定会出错，但是一旦在后期出现错误，需要再回到当初的修改来取消循环的代价又很大。

一般来说有几个办法避免这种问题：

- 优先在cpp文件中加入头文件。比如可以让`a.c`包含`b.h`的话就不要在`a.h`中包含。
- 使用forward declaration。这种方法偶尔会被用来破除引用循环，但是会导致声明不在同一个地方，增加维护成本。
- 尽量减少引用层级。比如减少没有必要的抽象化，如果`a.h`和`b.h`都属于某个功能，那把他们都放进`features.h`可能更好。

**代码分层**

清晰的代码的层次关系不仅仅会让维护变得方便，也会让不熟悉的项目的人更快的理解和参与。同时他们提交的修改也更加安全，因为局部的修改不太会牵一发而动全身。层次关系也会让单元测试变得方便，因为单元测试往往可以通过上下层之间的接口进行，让测试和实际代码更加解耦。

代码分层体现在两个方面

- 组件之间的层级关系
- 组件内部的层级关系

例如WebCore依赖JSC，那么这种依赖就是单向的，也就意味着WebCore可以访问JSC的头文件，而JSC无法访问WebCore头文件。我们知道JSC和WebCore都需要被编译成动态链接库，所以如果有反向依赖的话我们就会遇到链接错误。有些时候很多项目图个省事就会把所有东西全都编译到一起去，这其实是一个非常不好的习惯。因为边界一旦打破，后面再想修复的话成本会变得极高。

**隐藏内部实现**

一般来说一个组件如果被编译成动态或者静态库文件，那么其他组件使用的时候只需要包含相应的头文件，然后链接到库即可。有些项目会提供一个`include`目录，把所有对外可见的头文件放到这个目录下面。这样就避免了项目内部的头文件被有意或者无意的暴露出去。

这里依然会存在一个anti-pattern，就是把项目本身的代码目录当作包含路径暴露给所有依赖的库。这样做有几个坏处：

- 坏处之一：项目本身的根目录暴露给所有依赖的库以后就相当于暴露了所有头文件，这时候内部实现就完全暴露了。组件之间不再有一个清晰的层级关系。

这个怎么理解呢？举个例子，比如组件`b`依赖组件`a`，那么`b`和`a`的关系是“*b和a之间通过暴露在头文件种的API沟通*”。也就是说头文件和它内部的声明构成了一个contract（合同）。上下游组件之间依靠这个合同来协作，测试用例则以覆盖所有合同中的定义为标准。这个合同必须相对稳定并且易于维护。同时对于C/C++项目来说这个API contract也是保证ABI兼容的一部分。例如有些C++项目也会以`extern C`来声明导出函数。

如果失去了这一层API contract而直接把项目根目录暴露出去，那么所有内部定义都可以被使用，甚至内部定义的编译结果在不同组件当中会不一样。参考下面的代码：

```
// a.h
struct a {
#ifdef COMPONENT_A_INTERNAL_FLAG
    int x;
#endif
    int y;
};
```

这时候定义或者不定义`COMPONENT_A_INTERNAL_FLAG`会影响结构体的大小。那么如果这个结构体穿越了API边界，例如我`new`了一个`a`对象然后传递过去，另一边就会遇到越界访问的问题。这个问题有时候会非常隐蔽，比如一个函数以`move`的形式接受一个`unique_ptr`，这个`unique_ptr`包含着一个比较大的对象，它的成员有几十个，这几十个成员又间接有很多儿子孙子。某一天我在`struct a`里面加了一行`#ifdef`，然后发现程序莫名其妙就跑飞了，内存错误。这个错误和这一行修改还完全无关。

另外如果我在组件`a`中使用了某种特殊的`allocator`，而另一个组件没有用。那么当一个对象穿过API边界到另一边的时候就会造成严重的内存错误，因为两边的内存池不同。举个例子比如JSC中的堆内存必须由JSC自己管理，里面的所有JS对象生命周期都严格绑定在JSC/heap对象上。甚至那些JSC对象后面挂着的DOM对象都必须由JSC中的垃圾收集器负责间接回收。这个问题我们会在WebCore详细描述。

- 坏处之二：头文件名冲突以及需要使用包含路径。

头文件冲突很容易理解，我们把项目里面所有头文件都暴露出去了，和其他库甚至系统头文件冲突可能性是很大的。这里有两种“暴露”的方法，一种是暴露了项目中所有的目录，那么下游的项目只需要`#include <xxx.h>`就可以，冲突风险非常大。另一种是只暴露根目录，那么下游目录需要`#include <path/to/header.h>`来使用头文件。把头文件路径编码到API contract也是一个anti-pattern，非常不好。

**对象所有权关系混乱**

这个问题虽然是逻辑问题，但往往也和上面这些项目结构混乱有很大关系。比如在WebKit中JSC永远是被WebCore使用的一方，也就意味着WebCore中的某个对象会拥有JSC中执行上下文(ExecState)，WebCore会来初始化JSC，WebCore也会负责在合适的时候销毁它所创建过的所有相关对象。

所有反向的依赖，例如JavaScript的全局对象`window`则是通过反向注入的方式由WebCore注入JSC，而不是从JSC里面引用一个WebCore头文件然后直接包含一个类。

在项目结构很严谨的时候这一层关系是没办法打破的，企图这么做会很快得到编译错误。

### WebKit的选择

我们可以随便选一个头文件来看一下，例如`JavaScriptCore/runtime/Exception.h`。这个头文件在JSC和WebCore中都有使用。在JSC中搜索一下我们看到的都是：

```c++
#include "Exception.h"
```

而在WebCore和WebKit中我们看到的是：

```c++
#include <JavaScriptCore/Exception.h>
```

但问题是`Exception.h`明明在`runtime`目录下面，而不在一个叫做`JavaScriptCore`的目录下面。那么WebCore和WebKit这些上层组件时怎么找到它的？这时候我们就要进入下一个小节——`Forwarding Headers`

## Forwarding Headers

## export macros





## WTF
## JSC
### LLInt
#### LLLIntDesiredSettings.h
#### LLIntDesiredOffsets.h
#### Assembly
### LUT
### WASM
### Inspector
### Builtins
## WebCore
### IDL Bindings
## WebKit & WebKitLegacy
